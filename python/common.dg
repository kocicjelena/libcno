import '/os'
import '/sys'
import '/importlib'
import '/importlib/abc'
import '/importlib/machinery'
import '/distutils/core/Extension'
import '/distutils/core/Distribution'
import '/distutils/errors/CompileError'
import '/distutils/command/build_ext'
import '/distutils/ccompiler/new_compiler'


BuildExtInplace = subclass build_ext.build_ext where
  get_ext_fullpath = ext_name ~>
    fullname = @get_ext_fullname ext_name
    filename = @get_ext_filename $ fullname.rsplit '.' 1 !! -1
    os.path.join @build_into filename


CModuleLoader = subclass abc.Loader where
  __init__    = @name @filename ~>
  exec_module = module ~>
    dir = os.path.dirname @filename or os.curdir
    mod = @name.rsplit '.' 1 !! -1
    ext = Extension @name [@filename]
    # Use `PyMODINIT_FUNC_NAME` in place of `PyInit_something` and
    # `PyModuleDef_NAME` as the name of the module in a `PyModuleDef`.
    ext.define_macros.append ('PyMODINIT_FUNC_NAME', 'PyInit_' + mod)
    ext.define_macros.append ('PyModuleDef_NAME', '"' + mod.replace '"' '\\"' + '"')
    # C files may include some metadata in comments
    # at the start of the file. Like this:
    #
    #    //! library: m
    #    //! library: h2o
    #    //! library_dir: ./contrib
    #    //! file: something_else.c
    #
    for line in takewhile (x -> x.startswith '//! ') (open @filename) =>
      param, ok, value = line !! slice 4 None |>.partition ':'
      param = param.strip!
      value = value.strip!
      ok => if param == 'library'     => ext.libraries.append value
               param == 'library_dir' => ext.library_dirs.append $ os.path.join dir value
               param == 'include_dir' => ext.include_dirs.append $ os.path.join dir value
               param == 'file' => ext.sources.append $ os.path.join dir value

    cmd = BuildExtInplace $ Distribution $ dict ext_modules: [ext]
    cmd.build_into = os.path.dirname  @filename
    cmd.build_temp = os.path.join dir '__pycache__/clib'
    cmd.finalize_options!
    except err => cmd.run!
           err :: CompileError =>
             e = ImportError $ str err
             e.__cause__ = None
             raise e

    sys.modules.pop @name ''
    actual = importlib.import_module @name
    module.__dict__.update actual.__dict__


loaders = list ((sys.path_hooks.pop -1).__closure__ !! -1).cell_contents
loaders.append (CModuleLoader, ['.c'])
sys.path_importer_cache.clear!
sys.path_hooks.append $ machinery.FileFinder.path_hook *: loaders


color = subclass object where
  BLACK  = '\033[30;1m{}\033[0m'.format
  RED    = '\033[31;1m{}\033[0m'.format
  GREEN  = '\033[32;1m{}\033[0m'.format
  YELLOW = '\033[33;1m{}\033[0m'.format
  BLUE   = '\033[34;1m{}\033[0m'.format
  PURPLE = '\033[35;1m{}\033[0m'.format
  CYAN   = '\033[36;1m{}\033[0m'.format
  WHITE  = '\033[37;1m{}\033[0m'.format


nothing = subclass object where
  BLACK  = str
  RED    = str
  GREEN  = str
  YELLOW = str
  BLUE   = str
  PURPLE = str
  CYAN   = str
  WHITE  = str


print_colors = **: kwargs ->
  file = kwargs.get 'file' sys.stdout
  term = os.environ.get 'TERM' 'vt100'
  bind print **: kwargs, if
    term.startswith 'xterm' and file.isatty! => color
    otherwise                                => nothing


print_headers = async $ **: kwargs ~>
  print', color = print_colors **: kwargs
  for (k, v) in self =>
    print' ('    ' + color.BLUE k) v sep: ': '


print_request = async $ **: kwargs ~>
  print', color = print_colors **: kwargs
  print' '-> stream' @stream '=' (color.YELLOW @method) (color.WHITE @path)
  await print_headers @headers **: kwargs
  print '   payload length =' $ len $ await @payload


print_response = async $ **: kwargs ~>
  print', color = print_colors **: kwargs
  print' '-> stream' @stream '=' $ if (@code // 100 == 2 => color.GREEN @code) (otherwise => color.RED @code)
  await print_headers @headers **: kwargs
  print '   payload length =' $ len $ await @payload

  async for req in @pushed =>
    print '+ push promise ' end: ' ', await print_request  **: kwargs req
    print '+ push response' end: ' ', await print_response **: kwargs $ await req.response
